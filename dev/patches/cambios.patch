 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/dev/dev.html b/dev/dev.html
index 67b3c164386ed23a5ffa09707e25bebef527d2d6..8aa67def8279a7038e616eddbe153326efd6b1f6 100644
--- a/dev/dev.html
+++ b/dev/dev.html
@@ -717,80 +717,119 @@ body{
       </div>
     </div>
   </div>
 
 </div>
 
 <div id="tooltip" class="tooltip"></div>
 
 <script>
 const mailtoRecipient = 'showroom-itot@ejemplo.com';
 
 // --- NUEVO: lÃ³gica de calendario y horarios con lectura de CSV ---
 const DISPLAY_HOURS = ['09:00','10:00','11:00','12:00','13:00','14:00','15:00','16:00','17:00'];
 const RESERVABLE_HOURS = ['10:00','11:00','12:00','13:00','14:00','15:00','16:00'];
 let selectedDate = null;      // 'YYYY-MM-DD'
 let selectedTime = null;      // 'HH:MM'
 let reservationsByDate = {};  // { 'YYYY-MM-DD': ['11:00', '14:00'] }
 let availabilityByDate = {};
 let currentMonthDate = new Date();
 
 async function reservasdb(){
   try{
     const response = await fetch('../data/reservas.csv');
     if(!response.ok) throw new Error('No se pudo leer reservas.csv');
     const csvText = await response.text();
-    const lines = csvText.trim().split(/\r?\n/).filter(l=>l.trim().length>0);
-    if(lines.length === 0) return [];
+    const rows = parseCsv(csvText);
+    if(rows.length === 0) return [];
 
-    const headers = lines[0].split(',').map(h=>h.trim());
-    return lines.slice(1).map(line=>{
-      const values = line.split(',').map(v=>v.trim());
+    const headers = rows[0].map(h=>h.trim());
+    return rows.slice(1).map(values=>{
       const record = {};
-      headers.forEach((h,idx)=>{record[h]=values[idx]||'';});
+      headers.forEach((h,idx)=>{record[h]=values[idx]?.trim()||'';});
       const techList = (record.Tecnologias || record.Soluciones || '').split(';').map(t=>t.trim()).filter(Boolean);
 
       return {
         fecha: record.Fecha || record.fecha || record.date || '',
         horaInicio: record.HoraInicio || record.Hora || record.hora || '',
         horaFin: record.HoraFin || record.horafin || '',
         estado: record.Estado || record.estado || '',
         empresa: record.Empresa || record.empresa || '',
         sector: record.Sector || record.sector || '',
         numeroInvitados: record.NumeroInvitados || record.invitados || '',
         comentarios: record.Comentarios || record.comentarios || '',
         requiereEquipoLab: record.RequiereEquipoLab === true || record.RequiereEquipoLab === 'true' || record.RequiereEquipoLab === '1',
         invitadosDetalle: record.InvitadosJson || record.Invitados || '',
         tecnologias: techList
       };
     });
   }catch(err){
     console.error('No se pudieron leer las reservas desde el CSV', err);
     return [];
   }
 }
 
+// Parser simple para CSV con comillas y comas embebidas
+function parseCsv(text){
+  const rows = [];
+  let row = [];
+  let field = '';
+  let inQuotes = false;
+
+  for(let i=0; i<text.length; i++){
+    const char = text[i];
+    if(char === '"'){
+      const next = text[i+1];
+      if(inQuotes && next === '"'){
+        field += '"';
+        i++;
+      }else{
+        inQuotes = !inQuotes;
+      }
+    }else if(char === ',' && !inQuotes){
+      row.push(field);
+      field = '';
+    }else if((char === '\n' || char === '\r') && !inQuotes){
+      if(field.length>0 || row.length>0){
+        row.push(field);
+        rows.push(row);
+        row = [];
+        field = '';
+      }
+    }else{
+      field += char;
+    }
+  }
+
+  if(field.length>0 || row.length>0){
+    row.push(field);
+    rows.push(row);
+  }
+
+  return rows.filter(r=>r.some(v=>v.trim().length>0));
+}
+
 function normalizeTimeSlot(timeStr){
   if(!timeStr) return null;
   const parts = timeStr.toString().trim().split(':');
   const hour = parts[0];
   if(hour === undefined) return null;
   const hourNum = Number(hour);
   if(Number.isNaN(hourNum)) return null;
   return `${String(hourNum).padStart(2,'0')}:00`;
 }
 
 function addBlockedSlot(blockedSet,timeStr){
   const normalized = normalizeTimeSlot(timeStr);
   if(!normalized) return;
   const hour = parseInt(normalized.split(':')[0],10);
   if(Number.isNaN(hour)) return;
   [hour-1,hour,hour+1].forEach(h=>{
     const slot = `${String(h).padStart(2,'0')}:00`;
     if(DISPLAY_HOURS.includes(slot)){
       blockedSet.add(slot);
     }
   });
 }
 
 function buildAvailabilityMap(){
   availabilityByDate = {};
@@ -2544,26 +2583,25 @@ document.addEventListener('DOMContentLoaded',()=>{
         : 'N/A';
 
     document.title = version ? `SHOT DEV ${version}` : fallbackTitle;
     badge.textContent = version
       ? `DEV ${version} | Patch #${patchCounter} (${lastPatch})`
       : fallbackBadge;
   };
 
   fetch('../version.json')
     .then((response) => {
       if (!response.ok) throw new Error('Network response was not ok');
       return response.json();
     })
     .then((data) => {
       applyVersionData(data);
     })
     .catch(() => {
       document.title = fallbackTitle;
       badge.textContent = fallbackBadge;
     });
 })();
 </script>
 
 </body>
 </html>
-
 
EOF
)